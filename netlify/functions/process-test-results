// netlify/functions/process-test-results.js
const { createClient } = require('@supabase/supabase-js');
const ExcelJS = require('exceljs');
const { v4: uuidv4 } = require('uuid');
const multipart = require('parse-multipart');
const { processReportGeneration } = require('./utils/reportGenerator');

function log(level, message, data = null) {
  const timestamp = new Date().toISOString();
  const logLine = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
  
  if (data) {
    console.log(logLine, JSON.stringify(data, null, 2));
  } else {
    console.log(logLine);
  }
}

exports.handler = async function(event, context) {
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Content-Type': 'application/json'
  };

  try {
    if (event.httpMethod === 'OPTIONS') {
      return { statusCode: 200, headers, body: '' };
    }

    if (event.httpMethod !== 'POST') {
      return {
        statusCode: 405,
        headers,
        body: JSON.stringify({ error: 'Method not allowed' })
      };
    }

    // Environment validation
    if (!process.env.VITE_SUPABASE_URL || !process.env.VITE_SUPABASE_SERVICE_KEY) {
      return {
        statusCode: 500,
        headers,
        body: JSON.stringify({ error: 'Server configuration error' })
      };
    }

    // Create Supabase client
    const supabase = createClient(
      process.env.VITE_SUPABASE_URL,
      process.env.VITE_SUPABASE_SERVICE_KEY
    );

    // Authenticate user
    const authHeader = event.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      return {
        statusCode: 401,
        headers,
        body: JSON.stringify({ error: 'Authorization required' })
      };
    }

    const token = authHeader.substring(7);
    const { data: userData, error: userError } = await supabase.auth.getUser(token);
    
    if (userError || !userData?.user) {
      return {
        statusCode: 401,
        headers,
        body: JSON.stringify({ error: 'Authentication failed' })
      };
    }

    const user = userData.user;

    // Check if user is admin
    const { data: isAdminData, error: adminError } = await supabase.rpc('is_admin');
    if (adminError || !isAdminData) {
      return {
        statusCode: 403,
        headers,
        body: JSON.stringify({ error: 'Admin access required' })
      };
    }

    // Parse multipart form data
    const boundary = event.headers['content-type']?.split('boundary=')[1];
    if (!boundary) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: 'Invalid content type' })
      };
    }

    const parts = multipart.Parse(Buffer.from(event.body, 'base64'), boundary);
    
    // Extract form data
    let fileBuffer = null;
    let fileName = '';
    let testKitId = '';
    let workOrderNumber = '';
    let sampleNumber = '';

    for (const part of parts) {
      if (part.name === 'file') {
        fileBuffer = part.data;
        fileName = part.filename || 'uploaded-file';
      } else if (part.name === 'testKitId') {
        testKitId = part.data.toString();
      } else if (part.name === 'workOrderNumber') {
        workOrderNumber = part.data.toString();
      } else if (part.name === 'sampleNumber') {
        sampleNumber = part.data.toString();
      }
    }

    // Validate required fields
    if (!fileBuffer || !testKitId || !workOrderNumber || !sampleNumber) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: 'Missing required fields' })
      };
    }

    log('info', 'Processing test results upload', {
      testKitId,
      workOrderNumber,
      sampleNumber,
      fileName,
      fileSize: fileBuffer.length
    });

    // Process the file and generate report
    const result = await processTestResultsFile({
      supabase,
      user,
      fileBuffer,
      fileName,
      testKitId,
      workOrderNumber,
      sampleNumber
    });

    if (!result.success) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: result.error })
      };
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        success: true,
        reportId: result.reportId,
        message: 'Test results processed successfully'
      })
    };

  } catch (error) {
    log('error', 'Unexpected function error', { error: error.message });
    
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({ 
        error: 'Internal server error',
        message: error.message
      })
    };
  }
};

async function processTestResultsFile({
  supabase,
  user,
  fileBuffer,
  fileName,
  testKitId,
  workOrderNumber,
  sampleNumber
}) {
  const requestId = Math.random().toString(36).substring(2, 8);
  
  try {
    log('info', 'Starting file processing', { requestId, fileName });

    // Generate report UUID
    const reportId = uuidv4();

    // Create report record
    const { data: report, error: reportError } = await supabase
      .from('reports')
      .insert([{
        report_id: reportId,
        sample_number: sampleNumber,
        work_order_number: workOrderNumber,
        test_kit_id: testKitId,
        user_id: null, // Will be set later when we find the kit registration
        original_file_name: fileName,
        processing_status: 'processing'
      }])
      .select()
      .single();

    if (reportError) {
      throw new Error(`Failed to create report record: ${reportError.message}`);
    }

    log('info', 'Report record created', { reportId, requestId });

    // Convert file to CSV
    let csvContent;
    if (fileName.toLowerCase().endsWith('.csv')) {
      csvContent = fileBuffer.toString('utf-8');
    } else {
      csvContent = await convertExcelToCSV(fileBuffer);
    }

    // Store CSV in Supabase storage
    const csvFileName = `${reportId}-${sampleNumber}.csv`;
    const { data: csvUpload, error: csvUploadError } = await supabase.storage
      .from('test-results-csv')
      .upload(csvFileName, csvContent, {
        contentType: 'text/csv',
        upsert: true
      });

    if (csvUploadError) {
      throw new Error(`Failed to upload CSV: ${csvUploadError.message}`);
    }

    // Get CSV file URL
    const { data: csvUrl } = supabase.storage
      .from('test-results-csv')
      .getPublicUrl(csvFileName);

    log('info', 'CSV file uploaded', { csvFileName, requestId });

    // Parse and insert/update test results
    await processCSVData(supabase, csvContent, sampleNumber, workOrderNumber, requestId);

    // Find and update kit registration
    const kitUpdateResult = await updateKitRegistration(supabase, testKitId, workOrderNumber, sampleNumber, reportId, user.id);
    
    if (kitUpdateResult.success) {
      log('info', 'Kit registration updated successfully', {
        type: kitUpdateResult.type,
        kitRegistrationId: kitUpdateResult.kitRegistrationId,
        requestId
      });

      // Update the report record with the kit registration details
      const reportUpdateData = {
        csv_file_url: csvUrl.publicUrl,
        processing_status: 'processing'
      };

      if (kitUpdateResult.type === 'regular') {
        reportUpdateData.kit_registration_id = kitUpdateResult.kitRegistrationId;
        
        // Get the customer's user_id from the kit registration
        const { data: kitDetails } = await supabase
          .from('kit_registrations')
          .select('user_id')
          .eq('kit_registration_id', kitUpdateResult.kitRegistrationId)
          .single();
          
        if (kitDetails) {
          reportUpdateData.user_id = kitDetails.user_id;
        }
      } else if (kitUpdateResult.type === 'legacy') {
        reportUpdateData.legacy_kit_registration_id = kitUpdateResult.kitRegistrationId;
        
        // Get the customer's user_id from the legacy kit registration
        const { data: legacyKitDetails } = await supabase
          .from('legacy_kit_registrations')
          .select('user_id')
          .eq('id', kitUpdateResult.kitRegistrationId)
          .single();
          
        if (legacyKitDetails) {
          reportUpdateData.user_id = legacyKitDetails.user_id;
        }
      }

      // Update the report with the kit registration and customer info
      await supabase
        .from('reports')
        .update(reportUpdateData)
        .eq('report_id', reportId);

    } else {
      log('warn', 'Failed to update kit registration', {
        error: kitUpdateResult.error,
        requestId
      });

      // Still update the report with CSV URL even if kit registration update failed
      await supabase
        .from('reports')
        .update({
          csv_file_url: csvUrl.publicUrl,
          processing_status: 'processing'
        })
        .eq('report_id', reportId);
    }

    // Generate PDF report
    const pdfResult = await processReportGeneration(supabase, reportId, sampleNumber, requestId);
    
    if (pdfResult.success) {
      // Update report with PDF URL and completion status
      await supabase
        .from('reports')
        .update({ 
          pdf_file_url: pdfResult.pdfUrl,
          processing_status: 'completed'
        })
        .eq('report_id', reportId);
    } else {
      // Update with error status
      await supabase
        .from('reports')
        .update({ 
          processing_status: 'failed',
          error_message: pdfResult.error
        })
        .eq('report_id', reportId);
    }

    log('info', 'Test results processing completed', { reportId, requestId });

    return {
      success: true,
      reportId,
      csvUrl: csvUrl.publicUrl,
      pdfUrl: pdfResult.pdfUrl
    };

  } catch (error) {
    log('error', 'Error processing test results', { 
      error: error.message, 
      requestId 
    });

    // Update report status to failed if report was created
    try {
      await supabase
        .from('reports')
        .update({ 
          processing_status: 'failed',
          error_message: error.message
        })
        .eq('report_id', reportId);
    } catch (updateError) {
      log('error', 'Failed to update report status', { updateError: updateError.message });
    }

    return {
      success: false,
      error: error.message
    };
  }
}

async function convertExcelToCSV(fileBuffer) {
  try {
    const workbook = new ExcelJS.Workbook();
    await workbook.xlsx.load(fileBuffer);
    
    // Get the first worksheet
    const worksheet = workbook.getWorksheet(1);
    if (!worksheet) {
      throw new Error('No worksheet found in Excel file');
    }

    const csvRows = [];
    
    worksheet.eachRow((row, rowNumber) => {
      const csvRow = [];
      row.eachCell({ includeEmpty: true }, (cell, colNumber) => {
        let value = '';
        if (cell.value !== null && cell.value !== undefined) {
          // Handle different cell types
          if (typeof cell.value === 'object' && cell.value.result !== undefined) {
            // Formula cell
            value = cell.value.result;
          } else {
            value = cell.value;
          }
        }
        
        // Escape quotes and wrap in quotes if contains comma or quotes
        const stringValue = String(value);
        if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
          csvRow.push(`"${stringValue.replace(/"/g, '""')}"`);
        } else {
          csvRow.push(stringValue);
        }
      });
      csvRows.push(csvRow.join(','));
    });

    return csvRows.join('\n');
  } catch (error) {
    throw new Error(`Failed to convert Excel to CSV: ${error.message}`);
  }
}

async function processCSVData(supabase, csvContent, sampleNumber, workOrderNumber, requestId) {
  try {
    log('info', 'Processing CSV data', { sampleNumber, workOrderNumber, requestId });

    const lines = csvContent.split('\n').filter(line => line.trim());
    if (lines.length < 2) {
      throw new Error('CSV file must contain at least a header row and one data row');
    }

    // Parse CSV header
    const headers = parseCSVRow(lines[0]);
    log('info', 'CSV headers found', { headers, requestId });

    // Create column mapping for test_results_raw table schema
    const columnMapping = createColumnMapping(headers);
    log('info', 'Column mapping created', { columnMapping, requestId });

    // Convert work order and sample numbers to integers
    const workOrderInt = parseInt(workOrderNumber);
    const sampleNumberInt = parseInt(sampleNumber);

    if (isNaN(workOrderInt) || isNaN(sampleNumberInt)) {
      throw new Error('Work Order Number and Sample Number must be valid integers');
    }

    // Process each data row
    for (let i = 1; i < lines.length; i++) {
      const values = parseCSVRow(lines[i]);
      if (values.length === 0) continue; // Skip empty rows

      // Map CSV data to database columns using the schema
      const rowData = {
        "Work Order #": workOrderInt,
        "Sample #": sampleNumberInt
      };

      // Map each CSV column to the appropriate database column
      headers.forEach((header, index) => {
        if (values[index] !== undefined && values[index] !== '') {
          const dbColumn = columnMapping[header];
          if (dbColumn) {
            let value = values[index].trim();
            
            // Handle date fields
            if (dbColumn === "Received Date" || dbColumn === "Analysis Date") {
              // Try to parse date, if invalid, store as null
              const parsedDate = new Date(value);
              if (!isNaN(parsedDate.getTime())) {
                rowData[dbColumn] = parsedDate.toISOString().split('T')[0]; // YYYY-MM-DD format
              } else {
                rowData[dbColumn] = null;
              }
            } else {
              rowData[dbColumn] = value;
            }
          }
        }
      });

      // Ensure we have the required fields
      if (!rowData["Parameter"]) {
        log('warn', 'Skipping row without Parameter', { rowIndex: i, rowData });
        continue;
      }

      try {
        // Check if record exists using composite primary key
        const { data: existing, error: selectError } = await supabase
          .from('test_results_raw')
          .select('"Work Order #", "Sample #", "Parameter"')
          .eq('"Work Order #"', workOrderInt)
          .eq('"Sample #"', sampleNumberInt)
          .eq('"Parameter"', rowData["Parameter"])
          .single();

        if (selectError && selectError.code !== 'PGRST116') {
          log('warn', 'Error checking existing record', { error: selectError.message });
        }

        if (existing) {
          // Update existing record
          const { error: updateError } = await supabase
            .from('test_results_raw')
            .update(rowData)
            .eq('"Work Order #"', workOrderInt)
            .eq('"Sample #"', sampleNumberInt)
            .eq('"Parameter"', rowData["Parameter"]);

          if (updateError) {
            log('warn', 'Failed to update test result', { 
              error: updateError.message, 
              rowData: rowData 
            });
          } else {
            log('info', 'Updated test result', { 
              workOrder: workOrderInt, 
              sample: sampleNumberInt, 
              parameter: rowData["Parameter"] 
            });
          }
        } else {
          // Insert new record
          const { error: insertError } = await supabase
            .from('test_results_raw')
            .insert([rowData]);

          if (insertError) {
            log('warn', 'Failed to insert test result', { 
              error: insertError.message, 
              rowData: rowData 
            });
          } else {
            log('info', 'Inserted test result', { 
              workOrder: workOrderInt, 
              sample: sampleNumberInt, 
              parameter: rowData["Parameter"] 
            });
          }
        }
      } catch (rowError) {
        log('warn', 'Error processing row', { 
          error: rowError.message, 
          rowIndex: i, 
          rowData 
        });
      }
    }

    log('info', 'CSV data processing completed', { 
      sampleNumber, 
      workOrderNumber,
      rowsProcessed: lines.length - 1, 
      requestId 
    });

  } catch (error) {
    throw new Error(`Failed to process CSV data: ${error.message}`);
  }
}

function createColumnMapping(csvHeaders) {
  // Map common CSV header variations to the exact database column names
  const mapping = {};
  
  csvHeaders.forEach(header => {
    const lowerHeader = header.toLowerCase().trim();
    
    // Map to exact database column names (case-sensitive with quotes)
    switch (lowerHeader) {
      case 'work order #':
      case 'work order':
      case 'work_order':
      case 'workorder':
        mapping[header] = "Work Order #";
        break;
      case 'sample #':
      case 'sample':
      case 'sample_number':
      case 'samplenumber':
        mapping[header] = "Sample #";
        break;
      case 'sample date':
      case 'sample_date':
      case 'sampledate':
        mapping[header] = "Sample Date";
        break;
      case 'matrix':
        mapping[header] = "Matrix";
        break;
      case 'sample description':
      case 'sample_description':
      case 'description':
        mapping[header] = "Sample Description";
        break;
      case 'method':
      case 'test_method':
      case 'analysis_method':
        mapping[header] = "Method";
        break;
      case 'parameter':
      case 'parameter_name':
      case 'analyte':
        mapping[header] = "Parameter";
        break;
      case 'mdl':
      case 'method detection limit':
      case 'detection_limit':
        mapping[header] = "MDL";
        break;
      case 'result':
      case 'value':
      case 'concentration':
      case 'test_result':
        mapping[header] = "Result";
        break;
      case 'units':
      case 'unit':
      case 'uom':
        mapping[header] = "Units";
        break;
      case 'received date':
      case 'received_date':
      case 'receiveddate':
      case 'date_received':
        mapping[header] = "Received Date";
        break;
      case 'analysis date':
      case 'analysis_date':
      case 'analysisdate':
      case 'date_analyzed':
      case 'test_date':
        mapping[header] = "Analysis Date";
        break;
      case 'notes':
      case 'comments':
      case 'remarks':
        mapping[header] = "Notes";
        break;
      default:
        // If no mapping found, check if it exactly matches a database column
        const dbColumns = [
          "Work Order #", "Sample #", "Sample Date", "Matrix", "Sample Description", 
          "Method", "Parameter", "MDL", "Result", "Units", "Received Date", 
          "Analysis Date", "Notes"
        ];
        if (dbColumns.includes(header)) {
          mapping[header] = header;
        }
        break;
    }
  });
  
  return mapping;
}

function parseCSVRow(row) {
  const result = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < row.length; i++) {
    const char = row[i];
    
    if (char === '"') {
      if (inQuotes && row[i + 1] === '"') {
        current += '"';
        i++; // Skip next quote
      } else {
        inQuotes = !inQuotes;
      }
    } else if (char === ',' && !inQuotes) {
      result.push(current.trim());
      current = '';
    } else {
      current += char;
    }
  }
  
  result.push(current.trim());
  return result;
}

async function updateKitRegistration(supabase, testKitId, workOrderNumber, sampleNumber, reportId, adminUserId) {
  try {
    log('info', 'Updating kit registration', { testKitId, workOrderNumber, sampleNumber, reportId });

    // Strategy: Look for kit registrations that don't have work_order_number and sample_number set yet
    // We'll prioritize by test kit type and registration status
    
    // First try to find a regular kit registration that matches criteria
    const { data: regularKits, error: regularError } = await supabase
      .from('kit_registrations')
      .select(`
        kit_registration_id, 
        user_id, 
        work_order_number, 
        sample_number, 
        report_id,
        registration_status,
        order_items!inner (
          test_kit_id,
          orders!inner (
            order_number
          )
        )
      `)
      .eq('order_items.test_kit_id', testKitId)
      .eq('registration_status', 'registered')
      .is('work_order_number', null)
      .is('sample_number', null)
      .is('report_id', null)
      .order('created_at', { ascending: true })
      .limit(5);

    if (!regularError && regularKits && regularKits.length > 0) {
      // Use the oldest registered kit that matches our criteria
      const kitToUpdate = regularKits[0];
      
      const { error: updateError } = await supabase
        .from('kit_registrations')
        .update({
          work_order_number: workOrderNumber,
          sample_number: sampleNumber,
          report_id: reportId,
          updated_at: new Date().toISOString()
        })
        .eq('kit_registration_id', kitToUpdate.kit_registration_id);

      if (updateError) {
        log('warn', 'Failed to update regular kit registration', { error: updateError.message });
      } else {
        log('info', 'Regular kit registration updated', { 
          kitRegistrationId: kitToUpdate.kit_registration_id,
          orderNumber: kitToUpdate.order_items.orders.order_number,
          userId: kitToUpdate.user_id
        });
        return { success: true, type: 'regular', kitRegistrationId: kitToUpdate.kit_registration_id };
      }
    }

    // If no regular kit found, try legacy kit registrations
    const { data: legacyKits, error: legacyError } = await supabase
      .from('legacy_kit_registrations')
      .select(`
        id, 
        user_id, 
        kit_code,
        registration_status,
        work_order_number, 
        sample_number, 
        report_id,
        test_kits!inner (
          id,
          name
        )
      `)
      .eq('test_kits.id', testKitId)
      .eq('registration_status', 'registered')
      .is('work_order_number', null)
      .is('sample_number', null)
      .is('report_id', null)
      .order('created_at', { ascending: true })
      .limit(5);

    if (!legacyError && legacyKits && legacyKits.length > 0) {
      // Use the oldest registered legacy kit that matches our criteria
      const kitToUpdate = legacyKits[0];
      
      const { error: updateError } = await supabase
        .from('legacy_kit_registrations')
        .update({
          work_order_number: workOrderNumber,
          sample_number: sampleNumber,
          report_id: reportId,
          updated_at: new Date().toISOString()
        })
        .eq('id', kitToUpdate.id);

      if (updateError) {
        log('warn', 'Failed to update legacy kit registration', { error: updateError.message });
      } else {
        log('info', 'Legacy kit registration updated', { 
          legacyKitId: kitToUpdate.id,
          kitCode: kitToUpdate.kit_code,
          userId: kitToUpdate.user_id
        });
        return { success: true, type: 'legacy', kitRegistrationId: kitToUpdate.id };
      }
    }

    // If still no match, try any registered kit without these fields set (fallback)
    const { data: anyRegularKit, error: anyRegularError } = await supabase
      .from('kit_registrations')
      .select(`
        kit_registration_id, 
        user_id,
        order_items!inner (
          orders!inner (
            order_number
          )
        )
      `)
      .eq('registration_status', 'registered')
      .is('work_order_number', null)
      .is('sample_number', null)
      .is('report_id', null)
      .order('created_at', { ascending: true })
      .limit(1)
      .single();

    if (!anyRegularError && anyRegularKit) {
      const { error: updateError } = await supabase
        .from('kit_registrations')
        .update({
          work_order_number: workOrderNumber,
          sample_number: sampleNumber,
          report_id: reportId,
          updated_at: new Date().toISOString()
        })
        .eq('kit_registration_id', anyRegularKit.kit_registration_id);

      if (updateError) {
        log('warn', 'Failed to update fallback kit registration', { error: updateError.message });
      } else {
        log('info', 'Fallback kit registration updated', { 
          kitRegistrationId: anyRegularKit.kit_registration_id,
          orderNumber: anyRegularKit.order_items.orders.order_number,
          userId: anyRegularKit.user_id
        });
        return { success: true, type: 'regular', kitRegistrationId: anyRegularKit.kit_registration_id };
      }
    }

    log('warn', 'No suitable kit registration found to update', { 
      testKitId, 
      workOrderNumber, 
      sampleNumber,
      adminUserId,
      message: 'No registered kits found without existing work order and sample numbers'
    });

    return { success: false, error: 'No suitable kit registration found' };

  } catch (error) {
    log('error', 'Error updating kit registration', { error: error.message });
    return { success: false, error: error.message };
  }
}